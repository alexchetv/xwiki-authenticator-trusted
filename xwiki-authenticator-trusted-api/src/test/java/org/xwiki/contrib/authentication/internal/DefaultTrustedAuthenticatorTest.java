/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 */

package org.xwiki.contrib.authentication.internal;

import java.net.URL;
import java.net.URLEncoder;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import javax.inject.Provider;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import org.xwiki.component.util.DefaultParameterizedType;
import org.xwiki.contrib.authentication.AuthenticationPersistenceStore;
import org.xwiki.contrib.authentication.TrustedAuthenticationAdapter;
import org.xwiki.contrib.authentication.TrustedAuthenticationConfiguration;
import org.xwiki.contrib.authentication.TrustedAuthenticationConfiguration.CaseStyle;
import org.xwiki.contrib.authentication.TrustedAuthenticator;
import org.xwiki.contrib.authentication.UserManager;
import org.xwiki.model.internal.DefaultModelConfiguration;
import org.xwiki.model.internal.DefaultModelContext;
import org.xwiki.model.internal.reference.DefaultEntityReferenceValueProvider;
import org.xwiki.model.internal.reference.DefaultReferenceDocumentReferenceResolver;
import org.xwiki.model.internal.reference.DefaultReferenceEntityReferenceResolver;
import org.xwiki.model.internal.reference.DefaultStringDocumentReferenceResolver;
import org.xwiki.model.internal.reference.DefaultStringEntityReferenceResolver;
import org.xwiki.model.internal.reference.DefaultStringEntityReferenceSerializer;
import org.xwiki.model.reference.DocumentReference;
import org.xwiki.test.annotation.ComponentList;
import org.xwiki.test.mockito.MockitoComponentMockingRule;

import com.xpn.xwiki.XWiki;
import com.xpn.xwiki.XWikiContext;
import com.xpn.xwiki.web.XWikiRequest;
import com.xpn.xwiki.web.XWikiResponse;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.nullValue;
import static org.hamcrest.Matchers.containsInAnyOrder;
import static org.junit.Assert.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.argThat;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@ComponentList({
    DefaultModelConfiguration.class,
    DefaultModelContext.class,
    DefaultEntityReferenceValueProvider.class,
    DefaultStringEntityReferenceSerializer.class,
    DefaultStringEntityReferenceResolver.class,
    DefaultStringDocumentReferenceResolver.class,
    DefaultReferenceEntityReferenceResolver.class,
    DefaultReferenceDocumentReferenceResolver.class
    //,DefaultLoggerManager.class,
    //DefaultObservationManager.class
})
public class DefaultTrustedAuthenticatorTest
{
    private static final String USER_WIKI = "xwiki";
    private static final String USER_SPACE = "XWiki";

    private static final String TEST_USER = "test.user@example.com";
    private static final String VALID_TEST_USER = "test\\.user@example\\.com";
    private static final String TEST_USER_FN = USER_WIKI + ':' + USER_SPACE + '.' + VALID_TEST_USER;

    private static final DocumentReference TEST_USER_REF = new DocumentReference(USER_WIKI, USER_SPACE, TEST_USER);

    @Rule
    public final MockitoComponentMockingRule<TrustedAuthenticator> mocker =
        new MockitoComponentMockingRule(DefaultTrustedAuthenticator.class); //, Arrays.asList(Logger.class));

    private XWikiContext context;

    private TrustedAuthenticationConfiguration authConfig;

    private UserManager userManager;

    private TrustedAuthenticationAdapter authAdapter;

    private AuthenticationPersistenceStore store;

    private XWiki xwikimock;

    @Before
    public void before() throws Exception
    {
        //mocker.registerMemoryConfigurationSource();
        //LoggerManager loggerManager = mocker.getInstance(LoggerManager.class);
        //loggerManager.setLoggerLevel("org.xwiki", LogLevel.DEBUG);

        Provider<XWikiContext> contextProvider =
            mocker.getInstance(new DefaultParameterizedType(null, Provider.class, XWikiContext.class));
        context = mock(XWikiContext.class);
        xwikimock = mock(XWiki.class);
        when(contextProvider.get()).thenReturn(context);
        when(context.getWiki()).thenReturn(xwikimock);

        authConfig = mocker.getInstance(TrustedAuthenticationConfiguration.class);
        store = mock(AuthenticationPersistenceStore.class);
        authAdapter = mock(TrustedAuthenticationAdapter.class);
        when(authConfig.getPersistenceStore()).thenReturn(store);
        when(authConfig.getAuthenticationAdapter()).thenReturn(authAdapter);
        when(authConfig.getUserProfileCaseStyle()).thenReturn(CaseStyle.LOWERCASE);
        when(authConfig.getUserProfileReplacements()).thenReturn(Collections.<String, String>emptyMap());

        userManager = mocker.getInstance(UserManager.class);
    }

    @Test
    public void testAlreadyAuthenticatedInTrustedStore() throws Exception
    {
        when(store.retrieve()).thenReturn(TEST_USER_FN);
        when(authConfig.isPersistenceStoreTrusted()).thenReturn(true);

        assertThat(mocker.getComponentUnderTest().authenticate(), equalTo(TEST_USER_REF));
    }

    @Test
    public void testNoAuthenticationEvenInTrustedStore() throws Exception
    {
        when(authConfig.isPersistenceStoreTrusted()).thenReturn(true);
        assertThat(mocker.getComponentUnderTest().authenticate(), nullValue());
        verify(store, never()).clear();
        verify(store, never()).store(any(String.class));
    }

    @Test
    public void testNoMoreAuthenticatedButInUntrustedStore() throws Exception
    {
        when(store.retrieve()).thenReturn(TEST_USER_FN);
        assertThat(mocker.getComponentUnderTest().authenticate(), nullValue());
        verify(store, times(1)).clear();
        verify(store, never()).store(any(String.class));
    }

    @Test
    public void testNotAuthenticatedEvenInUntrustedStore() throws Exception
    {
        assertThat(mocker.getComponentUnderTest().authenticate(), nullValue());
        verify(store, never()).clear();
        verify(store, never()).store(any(String.class));
    }

    @Test
    public void testAlreadyAuthenticatedInUntrustedStore() throws Exception
    {
        when(store.retrieve()).thenReturn(TEST_USER_FN);
        when(authAdapter.getUserUid()).thenReturn(TEST_USER);
        when(authAdapter.getUserName()).thenReturn(TEST_USER);
        assertThat(mocker.getComponentUnderTest().authenticate(), equalTo(TEST_USER_REF));
        verify(store, never()).clear();
        verify(store, never()).store(any(String.class));
    }

    @Test
    public void testNewUserAuthenticationFailingCreationNotEmptyUntrustedStore() throws Exception
    {
        when(store.retrieve()).thenReturn("xwiki:XWiki.OtherUser");
        when(authAdapter.getUserUid()).thenReturn(TEST_USER);
        when(authAdapter.getUserName()).thenReturn(TEST_USER);
        assertThat(mocker.getComponentUnderTest().authenticate(), nullValue());
        verify(store, times(1)).clear();
        verify(store, never()).store(any(String.class));
    }

    @Test
    public void testNewUserAuthenticationFailingCreationEmptyUntrustedStore() throws Exception
    {
        when(authAdapter.getUserUid()).thenReturn(TEST_USER);
        when(authAdapter.getUserName()).thenReturn(TEST_USER);
        assertThat(mocker.getComponentUnderTest().authenticate(), nullValue());
        verify(store, never()).clear();
        verify(store, never()).store(any(String.class));
    }

    @Test
    public void testNewUserAuthenticationNotEmptyUntrustedStore() throws Exception
    {
        when(store.retrieve()).thenReturn("xwiki:XWiki.OtherUser");
        when(authAdapter.getUserUid()).thenReturn(TEST_USER);
        when(authAdapter.getUserName()).thenReturn(TEST_USER);
        when(userManager.createUser(TEST_USER_REF, new HashMap<String, String>())).thenReturn(true);
        assertThat(mocker.getComponentUnderTest().authenticate(), equalTo(TEST_USER_REF));
        verify(store, times(1)).clear();
        verify(store, times(1)).store(TEST_USER_FN);
    }

    @Test
    public void testNewUserAuthenticationEmptyUntrustedStore() throws Exception
    {
        when(authAdapter.getUserUid()).thenReturn(TEST_USER);
        when(authAdapter.getUserName()).thenReturn(TEST_USER);
        when(userManager.createUser(TEST_USER_REF, new HashMap<String, String>())).thenReturn(true);
        assertThat(mocker.getComponentUnderTest().authenticate(), equalTo(TEST_USER_REF));
        verify(store, never()).clear();
        verify(store, times(1)).store(TEST_USER_FN);
    }

    @Test
    public void testExistingUserAuthenticationWithoutUserPropertyMapping() throws Exception
    {
        when(authAdapter.getUserUid()).thenReturn(TEST_USER);
        when(authAdapter.getUserName()).thenReturn(TEST_USER);
        when(xwikimock.exists(TEST_USER_REF, context)).thenReturn(true);
        assertThat(mocker.getComponentUnderTest().authenticate(), equalTo(TEST_USER_REF));
        verify(store, never()).clear();
        verify(userManager, never()).synchronizeUserProperties(any(DocumentReference.class), any(Map.class), any(String.class));
        verify(store, times(1)).store(TEST_USER_FN);
    }

    private Map<String, String> getAuthInfo()
    {
        Map<String, String> authInfo = new HashMap<>();
        authInfo.put("mail", "user@example.com");
        authInfo.put("givenName", "john");
        authInfo.put("sn", "doe");
        return authInfo;
    }

    private Map<String, String> getUserPropertyMapping()
    {
        Map<String, String> propertyMapping = new HashMap<>();
        propertyMapping.put("email", "mail");
        propertyMapping.put("first_name", "givenName");
        propertyMapping.put("last_name", "sn");
        return propertyMapping;
    }

    private Map<String, String> getExtendedInfo()
    {
        Map<String, String> authInfo = getAuthInfo();
        Map<String, String> extInfo = new HashMap<>();
        for (Map.Entry<String, String> entry : getUserPropertyMapping().entrySet()) {
            extInfo.put(entry.getKey(), authInfo.get(entry.getValue()));
        }
        return extInfo;
    }

    @Test
    public void testExistingUserAuthenticationWithUserPropertyMapping() throws Exception
    {
        Map<String, String> userPropertyMapping = getUserPropertyMapping();

        when(authConfig.getUserPropertyMappings()).thenReturn(userPropertyMapping);
        when(authAdapter.getUserUid()).thenReturn(TEST_USER);
        when(authAdapter.getUserName()).thenReturn(TEST_USER);
        when(authAdapter.getUserProperty(any(String.class))).then(
            new Answer<String>()
            {
                @Override
                public String answer(InvocationOnMock invocationOnMock) throws Throwable
                {
                    return getAuthInfo().get((String) invocationOnMock.getArguments()[0]);
                }
            }
        );
        when(xwikimock.exists(TEST_USER_REF, context)).thenReturn(true);
        assertThat(mocker.getComponentUnderTest().authenticate(), equalTo(TEST_USER_REF));
        verify(store, never()).clear();
        verify(userManager, times(1)).synchronizeUserProperties(eq(TEST_USER_REF), eq(getExtendedInfo()), any(String.class));
        verify(store, times(1)).store(TEST_USER_FN);
    }

    private Map<String, Collection<String>> getGroupMapping()
    {
        Map<String, Collection<String>> groupMapping = new HashMap<String, Collection<String>>();
        groupMapping.put("GroupA", Arrays.asList("groupa", "groupc"));
        groupMapping.put("XWiki.GroupB", Arrays.asList("groupb"));
        groupMapping.put("XWiki.GroupC", Arrays.asList("groupc"));
        groupMapping.put("GroupD", Arrays.asList("groupa", "groupd"));
        return groupMapping;
    }

    @Test
    public void testGroupMapping() throws Exception
    {
        when(authConfig.getGroupMappings()).thenReturn(getGroupMapping());
        when(authAdapter.getUserUid()).thenReturn(TEST_USER);
        when(authAdapter.getUserName()).thenReturn(TEST_USER);
        when(authAdapter.isUserInRole("groupc")).thenReturn(true);
        when(xwikimock.exists(TEST_USER_REF, context)).thenReturn(true);
        assertThat(mocker.getComponentUnderTest().authenticate(), equalTo(TEST_USER_REF));
        verify(store, never()).clear();
        verify(userManager, times(1)).synchronizeGroupsMembership(eq(TEST_USER_REF),
            (Collection<DocumentReference>) argThat(containsInAnyOrder(
                new DocumentReference(USER_WIKI, USER_SPACE, "GroupA"),
                new DocumentReference(USER_WIKI, USER_SPACE, "GroupC"))),
            (Collection<DocumentReference>) argThat(containsInAnyOrder(
                new DocumentReference(USER_WIKI, USER_SPACE, "GroupB"),
                new DocumentReference(USER_WIKI, USER_SPACE, "GroupD"))),
            any(String.class));
        verify(store, times(1)).store(TEST_USER_FN);
    }

    @Test(expected = UnsupportedOperationException.class)
    public void testUnsupportedUsernameUidDiff() throws Exception
    {
        when(authAdapter.getUserUid()).thenReturn("userid");
        when(authAdapter.getUserName()).thenReturn("username");
        mocker.getComponentUnderTest().authenticate();
    }

    @Test
    public void testLogout() throws Exception
    {
        final String serverUrlStr = "http://www.example.com";
        final String redirectPath = "/bin/view/Main/";
        final String rewrittenUrl = "http://www.other.com/?redir=" + URLEncoder
            .encode(serverUrlStr + redirectPath, "UTF-8");
        URL serverUrl = new URL(serverUrlStr);
        when(context.getURL()).thenReturn(serverUrl);

        when(xwikimock.Param(any(String.class),any(String.class))).then(new Answer<String>()
        {
            @Override
            public String answer(InvocationOnMock invocationOnMock) throws Throwable
            {
                return (String) invocationOnMock.getArguments()[1];
            }
        });

        XWikiRequest request = mock(XWikiRequest.class);
        when(request.getScheme()).thenReturn("http");
        when(request.getServletPath()).thenReturn("/bin");
        when(request.getPathInfo()).thenReturn("/logout/Main/");
        when(context.getRequest()).thenReturn(request);

        XWikiResponse response = mock(XWikiResponse.class);
        when(response.encodeRedirectURL(rewrittenUrl)).thenReturn(rewrittenUrl);
        when(context.getResponse()).thenReturn(response);

        when(store.retrieve()).thenReturn(TEST_USER_FN);
        when(authAdapter.getUserUid()).thenReturn(TEST_USER);
        when(authAdapter.getUserName()).thenReturn(TEST_USER);
        when(authConfig.getLogoutPagePattern()).thenReturn("(/|/[^/]+/|/wiki/[^/]+/)logout/*");

        assertThat(mocker.getComponentUnderTest().authenticate(), equalTo(TEST_USER_REF));
        verify(context, never()).setResponse(any(RedirectionRewritingResponseWrapper.class));

        ArgumentCaptor<RedirectionRewritingResponseWrapper> wrapperCaptor =
            ArgumentCaptor.forClass(RedirectionRewritingResponseWrapper.class);

        when(authAdapter.getLogoutURL(any(String.class))).then(new Answer<String>()
            {
                @Override
                public String answer(InvocationOnMock invocationOnMock)
                   throws Throwable
                {
                    if ((serverUrlStr + redirectPath).equals(invocationOnMock.getArguments()[0])) {
                        return rewrittenUrl;
                    }
                    return "";
                }
            }
        );
        assertThat(mocker.getComponentUnderTest().authenticate(), equalTo(TEST_USER_REF));
        verify(context, times(1)).setResponse(wrapperCaptor.capture());

        wrapperCaptor.getValue().sendRedirect(redirectPath);
        verify(authAdapter, times(2)).getLogoutURL(null);
        verify(authAdapter, times(1)).getLogoutURL(serverUrlStr + redirectPath);
        verify(response, times(1)).sendRedirect(rewrittenUrl);
    }
}
